/**
 * Update Post Use Case
 *
 * Handles post updates with ownership verification and business rules.
 */

import { UpdatePostDtoSchema, PostStatus } from '@blog/shared/domain';
import type { IPostRepository } from '../../ports/repositories/post.repository.interface.js';
import type { IUserRepository } from '../../ports/repositories/user.repository.interface.js';
import type { ICategoryRepository } from '../../ports/repositories/category.repository.interface.js';
import type { ITagRepository } from '../../ports/repositories/tag.repository.interface.js';
import { type Result, success, failure, ErrorCodes } from '../common/result.js';

export interface UpdatePostInput {
  postId: string;
  userId: string;
  updates: {
    title?: string;
    content?: string;
    excerpt?: string;
    featuredImageUrl?: string | null;
    categoryIds?: string[];
    tagIds?: string[];
    status?: 'draft' | 'published' | 'archived';
    visibility?: 'public' | 'private' | 'unlisted';
  };
}

export interface UpdatePostOutput {
  post: {
    id: string;
    authorId: string;
    title: string;
    slug: string;
    content: string;
    excerpt: string | null;
    status: string;
    visibility: string;
    updatedAt: Date;
  };
  requiresReembedding: boolean;
}

export interface UpdatePostDependencies {
  postRepository: IPostRepository;
  userRepository: IUserRepository;
  categoryRepository: ICategoryRepository;
  tagRepository: ITagRepository;
}

export class UpdatePostUseCase {
  constructor(private readonly deps: UpdatePostDependencies) {}

  async execute(input: UpdatePostInput): Promise<Result<UpdatePostOutput>> {
    // 1. Validate input
    const validation = UpdatePostDtoSchema.safeParse(input.updates);
    if (!validation.success) {
      return failure(ErrorCodes.VALIDATION_ERROR, 'Invalid input', {
        errors: validation.error.flatten().fieldErrors,
      });
    }

    // 2. Find post
    const post = await this.deps.postRepository.findById(input.postId);
    if (!post || post.isDeleted()) {
      return failure(ErrorCodes.POST_NOT_FOUND, 'Post not found');
    }

    const postData = post.toJSON();

    // 3. Verify ownership or admin (BR-01)
    const user = await this.deps.userRepository.findById(input.userId);
    if (!user) {
      return failure(ErrorCodes.USER_NOT_FOUND, 'User not found');
    }

    const userData = user.toJSON();
    const isOwner = postData.authorId === input.userId;
    const isAdmin = userData.isAdmin;

    if (!isOwner && !isAdmin) {
      return failure(
        ErrorCodes.UNAUTHORIZED_TO_EDIT,
        'You do not have permission to edit this post'
      );
    }

    // 4. Validate categories if provided
    if (input.updates.categoryIds && input.updates.categoryIds.length > 0) {
      const categories = await this.deps.categoryRepository.findByIds(
        input.updates.categoryIds
      );
      if (categories.length !== input.updates.categoryIds.length) {
        return failure(
          ErrorCodes.VALIDATION_ERROR,
          'One or more categories not found'
        );
      }
    }

    // 5. Validate tags if provided
    if (input.updates.tagIds && input.updates.tagIds.length > 0) {
      const tags = await this.deps.tagRepository.findByIds(
        input.updates.tagIds
      );
      if (tags.length !== input.updates.tagIds.length) {
        return failure(
          ErrorCodes.VALIDATION_ERROR,
          'One or more tags not found'
        );
      }
    }

    // 6. Check if content changed significantly (BR-05)
    let requiresReembedding = false;
    if (input.updates.content) {
      requiresReembedding = post.hasContentChangedSignificantly(
        input.updates.content
      );
    }

    // 7. Check if slug needs regeneration (title changed)
    if (input.updates.title && input.updates.title !== postData.title) {
      // Slug will be regenerated by post.update()
      // Check if new slug would be unique
      const newSlug = this.generateSlug(input.updates.title);
      const slugExists = await this.deps.postRepository.slugExists(
        newSlug,
        input.postId
      );

      if (slugExists) {
        // Add suffix to make unique
        let uniqueSlug = newSlug;
        let suffix = 1;
        while (
          await this.deps.postRepository.slugExists(uniqueSlug, input.postId)
        ) {
          uniqueSlug = `${newSlug}-${suffix}`;
          suffix++;
          if (suffix > 10) {
            return failure(
              ErrorCodes.VALIDATION_ERROR,
              'Could not generate unique slug for this title'
            );
          }
        }
        // Update title to generate correct slug
        // Note: This is a limitation - we may need to handle slug separately
      }
    }

    // 8. Update post
    post.update({
      title: input.updates.title,
      content: input.updates.content,
      excerpt: input.updates.excerpt,
      featuredImageUrl: input.updates.featuredImageUrl,
      status: input.updates.status,
      visibility: input.updates.visibility,
    });

    // 9. Handle publishing
    if (
      input.updates.status === PostStatus.PUBLISHED &&
      postData.status !== PostStatus.PUBLISHED
    ) {
      post.publish();
    } else if (
      input.updates.status === PostStatus.DRAFT &&
      postData.status === PostStatus.PUBLISHED
    ) {
      post.unpublish();
    } else if (input.updates.status === PostStatus.ARCHIVED) {
      post.archive();
    }

    // 10. Save post
    await this.deps.postRepository.save(post);

    // 11. TODO: If requiresReembedding and post is published, queue re-embedding
    // This would be handled by an event/message queue in production

    // 12. Return result
    const updatedPostData = post.toJSON();
    return success({
      post: {
        id: updatedPostData.id,
        authorId: updatedPostData.authorId,
        title: updatedPostData.title,
        slug: updatedPostData.slug,
        content: updatedPostData.content,
        excerpt: updatedPostData.excerpt,
        status: updatedPostData.status,
        visibility: updatedPostData.visibility,
        updatedAt: updatedPostData.updatedAt,
      },
      requiresReembedding,
    });
  }

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
